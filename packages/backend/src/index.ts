import Fastify  from 'fastify'
import fastifyCookie from '@fastify/cookie'
import fastifySwagger from '@fastify/swagger';
import fastifySwaggerUi from '@fastify/swagger-ui';
import urlData from '@fastify/url-data';
import multipart from '@fastify/multipart';
import { FastifyRequest } from 'fastify';
import fastifyCors from '@fastify/cors';

import {
  fastifyTRPCPlugin,
  FastifyTRPCPluginOptions,
} from '@trpc/server/adapters/fastify'

import { 
  appRouter, 
  type AppRouter,
  openAPIDocument  
} from 'src/trpc/router.ts'

import logger from 'src/lib/logger.ts'
import { createContext } from 'src/trpc/context.ts'
import store from '@whisper-webui/lib/src/db/store.ts'
import { 
  UnauthorizedException, 
  BadRequestException,
  ForbiddenException
} from '@whisper-webui/lib/src/db/exceptions.ts'
import lib from '@whisper-webui/lib/src/lib/index.ts'
import DAO from '@whisper-webui/lib/src/db/DAO.ts'


const PORT: number = 9000

const app = Fastify({ logger: false })
 
app.register(fastifyCors, { 
  origin: ['https://localhost:8443'], 
  credentials: true,
})
app.register(fastifyCookie)
app.register(multipart, { limits: { fileSize: 4 * 1024 * 1024 * 1024 } } ) // max file size 4GB
app.register(urlData)


// register trpc server
app.register(fastifyTRPCPlugin, {
  prefix: '/trpc',
  trpcOptions: {
    router: appRouter,
    createContext,
    onError({ path, error }) {
      console.error(`Error in tRPC handler on path '${path}': ${error}`)
    },
  } satisfies FastifyTRPCPluginOptions<AppRouter>['trpcOptions'],
})

// Register Swagger
app.register(fastifySwagger, {
  mode: 'static',
  specification: {
    document: openAPIDocument, // Use the OpenAPI document generated by openapi-trpc
  },
});

app.register(fastifySwaggerUi, {
  routePrefix: '/docs', // Swagger UI will be available at http://localhost:9000/docs
  uiConfig: {
    docExpansion: 'list',
    deepLinking: true,
  },
});

app.addHook('preHandler', async (request, reply) => {})
app.addHook('onResponse', async (request, reply) => {})

// Handle whisper video upload
app.route({
  method:`POST`,
  url: `/transcription/upload`,
  schema: {
    querystring: {
      type: 'object',
      properties: {
        lang: { 
          type: 'string', 
          enum: ['ar', 'zh', 'de', 'el', 'en', 'es', 'fa', 'fr', 'it', 'ja', 'hu', 'nl', 'pl', 'pt', 'ru', 'fi', 'tr', 'uk'] 
        } 
      },
      required: ['lang'],
    },
  },
  handler: async (req: FastifyRequest<{ Querystring: { lang: string} }>, res) => {
    // first check if the user is logged in
    const [_, sessionId] = req.headers.cookie?.split(`=`) || []
    if (!sessionId) 
      throw new ForbiddenException(`No sessionId provided`)
    
    if (sessionId.length != 24)
      throw new ForbiddenException(`Invalid sessionId provided`)

    for (let i = 0; i < 24; i++) {
      const charCode = sessionId.charCodeAt(i)
      if (!(charCode >= 48 && charCode <= 57) && !(charCode >= 65 && charCode <= 70))
        throw new ForbiddenException(`Invalid sessionId provided`)
    }

    // get the user
    const user = await store.getSession(sessionId)
    if (!user)
      throw new ForbiddenException(`Session not found`)

    // get the file informations
    const data = await req.file({limits: {
      files: 1,
      fileSize: 4 * 1024 * 1024 * 1024 // max file size 4GB
    }})

    if (!data) 
      throw new BadRequestException(`No file uploaded or invalid file`)
    
    // only audio/video are accepted
    const mimetype = data.mimetype;
    if (!mimetype.includes(`video`) && !mimetype.includes(`audio`))
      throw new BadRequestException(`The file is not audio/video`)

    // get file informations
    const name = data.filename.trim()
    // sanitize the filename
    const filename = data.filename
      .trim()
      .slice(-255)
      .normalize('NFKD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/[\/?<>\\:*|"]/g, `-`)
      .replace(/^\.+$/, `-`)
      .replace(/^(con|prn|aux|nul|com\d|lpt\d)(\..*)?$/i, `-`)
      .replace(/[. ]+$/, '')
      .replace(/[^a-z0-9._-]+/gi, `-`)
      .replace(/-{2,}/g, `-`)
      .replace(/^-+|-+$/g, '')

    console.log(
      `\n=== New transcription file incoming ===\n` +
      `UserId: ${user.id}\n` +
      `Email: ${user.email}\n` +
      `Name: ${name}\n` +
      `Filename: ${filename}\n` +
      `Mimetype: ${mimetype}\n` +
      `FilePath: `);

    // save to db
    const uid = lib.uid.genUID()
    await DAO.transcriptions.createTranscription({
      id: uid,
      name: filename,
      file: filename,
      lang: req.query.lang,
      status: `waiting`,
      created: new Date(),
      deleted: 0
    })
    
    res.code(200).send(await DAO.transcriptions.findById(uid))

    /*
    const data = await req.file({limits: {
      files: 1,
      fileSize: config.whisper.maxFileSize
    }});

    const name: string     = data.filename.trim();
    const filename: string = utils.str.sanitizeFileName(data.filename);
    const mimetype: string = data.mimetype;

    const fileUID: string    = utils.uid();
    const folderPath: string = path.join(config.whisper.in, fileUID);
    const filePath: string   = path.join(folderPath, filename);
    
    console.log(
    `\n=== New transcription file incoming ===\n` +
    `UserId: ${req.user.id}\n` +
    `Email: ${req.user.email}\n` +
    `Name: ${name}\n` +
    `Filename: ${filename}\n` +
    `Mimetype: ${mimetype}\n` +
    `FilePath: ${filePath}`);

    // we only accept audio and video files
    if (!mimetype.includes(`video`) && !mimetype.includes(`audio`))
      throw new InvalidRequestException(`The file is not audio/video`);
    
    // save the uploaded file into the destination folder
    await fs.promises.mkdir(folderPath);
    await pump(data.file, fs.createWriteStream(filePath));

    // send back the transcription
    res.code(200).send({
      uid: fileUID,
      filename: data.filename // original filename 
    });
    */

  }
})




try {
  await app.listen({ host:`0.0.0.0`, port: PORT })
  logger.info(`startup`, `Backend is listening on port ${PORT} in ${process.env.NODE_ENV} mode`)
} catch (err) {
  
  logger.error('startup', 'Backend failed to start', err instanceof Error ? err : new Error(String(err)))
  process.exit(1)
}


// to-do: log 
process.on('uncaughtException', (error) => {
  logger.error('uncaughtException', 'Uncaught Exception', error)
})
process.on('unhandledRejection', (reason, promise) => {
  logger.error('unhandledRejection', 'Unhandled Rejection', reason instanceof Error ? reason : new Error(String(reason)))
})